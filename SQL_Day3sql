-- Single row function
-- will affect each and every row and return same number of rows
-- length, upper, lower, substr

select upper(first_name) , lower(last_name) , 
substr(first_name , 1, 1) || substr(last_name , 1,1) 
as Initials
from employees;

-- to print just the Initials column

select
upper(concat(substr(first_name , 1, 1), substr(last_name , 1,1)))
"Initials"
from employees;


-- partial string condition using like %
-- find employees that contains MI in their name, case sensative

SELECT FIRST_NAME , LAST_NAME
from employees
--WE CAN ALSO DO THIS BY MAKING EVERYTHING LOWER CASE
WHERE LOWER (FIRST_NAME) LIKE '%mi%' OR
-- OR WE CAN ALSO DO THE SAME THING BY MAKING EVERYTHING UPPER CASE
UPPER(LAST_NAME) LIKE '%MI%';


-- FROM SUBSTRING TAKES 3 PARAMETERs:
-- 1. what parameter we want to use (hire_date)
-- 2. the starting point of the String
-- 3. the last number is the num of char in the following String

SELECT 
SUBSTR(HIRE_DATE , 4, 3)
-- THE FIRST NUMBER HERE REPRESENTS THE FIRST CHAR WE WANT TO START READING FROM
-- THE SECOND NUMBER IS REPRESENTS THE NUMBER OF CHARS IN THAT PARTICULAR STRING
FROM employees; 

-- FIND OUT EVERYONE WHO IS HIRED IN JAN

SELECT FIRST_NAME ,HIRE_DATE
FROM EMPLOYEES
WHERE SUBSTR(HIRE_DATE , 4,3)='JAN';

SELECT FIRST_NAME ,HIRE_DATE
FROM EMPLOYEES
WHERE SUBSTR(HIRE_DATE , 4,3) LIKE 'JAN';


SELECT FIRST_NAME ,HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE LIKE '%JAN%';

-- MATH OPERATION IN SQL (LETS CLEAR THIS OUT BEFORE WE TALK ABOUT MULTI-ROW FUNCTION)
-- MATH OPERATIONS ARE SAME LIKE IN JAVA
-- FOR FRACTIONAL NUMBER WE CAN USE ROUND FUNCTION TO ROUND UP THE NUMBER 
SELECT SALARY AS MONTHLY_SALARY, 
SALARY +1000 AS AFTER_RAISE ,
SALARY/4 AS WEEKLY_SALARY, 
SALARY /30 AS DAILY_SALARY,
--ROUND (SALARY/30) AS ROUNDED_DAILY
-- THIS ABOVE MAKES IT ROUNDED
ROUND (SALARY/30 , 2) AS ROUNDED_DAILY
FROM EMPLOYEES;
-- IF WE WANT TO KEEP 2 DIGITS AFTER COMA USE THE ONE ABOVE


--COUNT HOW MANY EMPLOYEES ARE IN EMPLOYEE MATTER 

SELECT * FROM EMPLOYEES;
SELECT COUNT(*) 
FROM EMPLOYEES;
SELECT COUNT(FIRST_NAME) FROM EMPLOYEES;

-- TASK: COUNT THE ROW COUNT OF EACH AND EVERY TABLE
SELECT COUNT(*)AS DEP_COUNTS FROM departments;
SELECT COUNT(*)AS JOB_HISTORY FROM JOB_HISTORY;
SELECT COUNT(*) AS COUNTRIES FROM COUNTRIES;
SELECT COUNT(*) AS REGIONS FROM REGIONS;
SELECT COUNT(*)AS LOCATIONS FROM LOCATIONS;
SELECT COUNT(*) AS JOBS FROM JOBS;


-- FIND MAX SALARY
SELECT MAX(SALARY) FROM employees;
SELECT MIN(SALARY) FROM employees;
SELECT SUM(SALARY) FROM employees;
SELECT AVG(SALARY) , 
        ROUND(AVG(SALARY) ) AS AVERAGE_SALARY,
        ROUND(AVG (SALARY) , 2) AS AVERAGE_SAL_2DIGITS


FROM employees;

-- FIND OUT ALL OF THAT ABOVE IN JUST ONE SHOT:

SELECT COUNT(*) AS EMPLOYEE_COUNT ,
        MAX(SALARY) AS MAX_SALARY ,
        MIN(SALARY) AS MIN_SALART ,
        SUM(SALARY) AS SALARY_TOTAL ,
        ROUND(AVG(SALARY) , 2) AS AVERAGE_SAL_2DIGITS
FROM EMPLOYEES;


-- find out how many employees in each departments:
select department_id , count(*) AS DEP_EMP_ID_COUNT
from employees
group BY department_id;
-- group BY GROUPS BY CERTAIN CRITERIA WE INDICATE
-- group BY function is veru strict as to where and how we can use it.


-- find out HOW MANY EMPLOYEE IN EACH  job_id category
-- WHENEVER WE WANT TO SAY HOW MANY --> USE COUNT WORD AS BELOW
select JOB_ID ,count(*) AS JOB_ID_COUNT
from employees
group by JOB_ID; 

-- THIS IS A BAD EXAMPLE OF QUERY, BAD QUERY! 
-- IF WE ADD ANY EXTRA COLUMN
--WE MUST USE GROUP BY TO SPECIFY THE GROUPING CRITERIA!!


--THIS DOESNT MAKE SENSE
-- GROUP BY CAN ONLY BE USED WITH AGGREGATE FUNCTION (COUNT)
-- AGGREGATE FUNCTION CAN ONLY BE USED WITH GROUP BY FUNCTION

SELECT FIRST_NAME
FROM employees
GROUP BY JOB_ID;


-- find out maxsalary in each DEPARTMENT_ID category
-- THE MOMENT WE HEAR WORD EACH --> WE ALWAYS USE GROUP BY AND AGGREGATION
-- AS LONG AS WE HAVE ONE EXTRA COLUMN IN OUR SELECT 
-- WE MUST HAVE GROUP BY
SELECT DEPARTMENT_ID , COUNT(*) AS EMPLOYEE_COUNT ,
MAX(SALARY ) AS MAX_SALARY, MIN(SALARY) AS MIN_SALARY , 
SUM(SALARY) AS TOTAL_SALARY_2DIGTS , 
ROUND(AVG(SALARY)) AS AVG_SALARY 
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;


-- FIND OUT HOW MANY EMPLOYEE IN EACH DEPARTMENTS
-- RESTRICT THE RESULT TO DISPLAY ONLY THOSE DEPARTMENTS WITH EMPL COUNT MORE THAN 10

-- IF YOU HAVE MORE CONDITIONS AFTER GROUP BY
-- WE CAN USE CLAUSE(WHERE DOES NOT WORK HERE )


SELECT DEPARTMENT_ID  , COUNT(*) AS DEP_EMP_CNT
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*)>10; -- THIS AGGREGATION FUNCTION CAN BE USED AGTER HAVING TO RESTRICT RESULTS EVEN MORE 
-- WHERE WORD  DOES NOT WORK HERE
-- HAVING CAN BE USED ONLY AFTER THE GROUP BY, ANYWHERE ELSE IT WILL NOT WORK



-- BY EXTENDING ABOVE QUERY, FIND OUT DEPARMENT WITH MAX SALARY LESS THAN 10.000
SELECT DEPARTMENT_ID  , COUNT(*) AS DEP_EMP_CNT
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY) < 10000; 


-- FIND OUT FROM LOCATION TABLE, FIND OUT HOW MANY LOCATION IN EACH COUNTRY (_ID)
SELECT COUNTRY_ID , COUNT(*)
FROM LOCATIONS
GROUP BY COUNTRY_ID;


-- HOW DO I SORT IN SQL?
--WE USE ORDER BY CLAUSE --> CLAUSE MEANS SPECIAL WORD, EXPRESSION, KEYWORD
-- ORDER BY COLUMN NAME 

SELECT * FROM EMPLOYEES 
ORDER BY SALARY ASC ; --> ASC - STANDS FOR ASCENDING ORDER -- DEFAULT LOW TO HIGH


SELECT * FROM EMPLOYEES 
ORDER BY SALARY DESC ; --> DESC - STANDS FOR DESCENDING ORDER -- DEFAULT HIGH TO LOW

SELECT MAX(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY department_id;


-- FIND OUT MAX SALARY IN EACH DEPARTMENT_ID  AND ORDER BY DEPARTMENT_ID
SELECT MAX(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID 
ORDER BY DEPARTMENT_ID;







